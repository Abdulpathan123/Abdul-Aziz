<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subway Surfer Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #87CEEB;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            background: url('background.png') repeat-y; /* Replace with your background image */
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const playerWidth = 60;
        const playerHeight = 80;
        let playerX = canvas.width / 2 - playerWidth / 2;
        let playerY = canvas.height - playerHeight - 10;
        const playerSpeed = 10;

        let obstacles = [];
        const obstacleWidth = 60;
        const obstacleHeight = 80;
        const obstacleSpeed = 4;

        let lanes = [canvas.width / 4, canvas.width / 2, (canvas.width / 4) * 3];
        let currentLane = 1; // Start in the middle lane

        const playerImage = new Image();
        playerImage.src = 'player.png'; // Replace with your player image

        const obstacleImage = new Image();
        obstacleImage.src = 'obstacle.png'; // Replace with your obstacle image

        const backgroundImage = new Image();
        backgroundImage.src = 'background.png'; // Replace with your background image

        function drawPlayer() {
            ctx.drawImage(playerImage, lanes[currentLane], playerY, playerWidth, playerHeight);
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.drawImage(obstacleImage, obstacle.x, obstacle.y, obstacleWidth, obstacleHeight);
            });
        }

        function updateObstacles() {
            obstacles.forEach(obstacle => {
                obstacle.y += obstacleSpeed;
            });
            obstacles = obstacles.filter(obstacle => obstacle.y < canvas.height);
        }

        function generateObstacle() {
            if (Math.random() < 0.02) {
                const x = lanes[Math.floor(Math.random() * lanes.length)];
                obstacles.push({ x, y: -obstacleHeight });
            }
        }

        function checkCollision() {
            return obstacles.some(obstacle => 
                lanes[currentLane] < obstacle.x + obstacleWidth &&
                lanes[currentLane] + playerWidth > obstacle.x &&
                playerY < obstacle.y + obstacleHeight &&
                playerY + playerHeight > obstacle.y
            );
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height); // Draw background

            drawPlayer();
            drawObstacles();
            updateObstacles();
            generateObstacle();

            if (checkCollision()) {
                alert('Game Over!');
                obstacles = [];
                playerX = canvas.width / 2 - playerWidth / 2;
                playerY = canvas.height - playerHeight - 10;
            }

            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' && currentLane > 0) {
                currentLane--;
            } else if (e.key === 'ArrowRight' && currentLane < lanes.length - 1) {
                currentLane++;
            }
        });

        gameLoop();
    </script>
</body>
</html>
